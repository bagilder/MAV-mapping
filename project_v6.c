#pragma config(Sensor, S1,     sonarL,         sensorSONAR)
#pragma config(Sensor, S2,     sonarR,         sensorSONAR)
#pragma config(Motor,  motorA,          motorL,        tmotorNXT, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorB,          motorR,        tmotorNXT, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/************************************************************************************************/
//Variable Declarations
	//Robot Geometry
	const float rl = 1.1;
	const float rr = 1.1;
	const float al = 6.625/2;
	const float ar = 6.625/2;
	const float a = (al+ar)/2;

	//Motors
	const float slopeL = 6.76;
	const float slopeR = 6.76;

	//Sonar Sensors
	int distL = 0;
	int distR = 0;

	//Position
	const float x0 = 0;
	const float y0 = 0;
	const float theta0 = 0;
	float pos[3] = {x0,y0,theta0};

	//Speed
	const float speed = 4; // units: in/s
	const float rot = PI/2; // rad/s

/************************************************************************************************/
//Functions

//Delta t function
	//MIGHT NEED TO INCLUDE METHOD FOR CHANGES IN THETA ONLY
float DeltaT(float dx, float dy, float dtheta){
	float mag = sqrt(dx*dx + dy*dy);
	float dt = mag/speed + dtheta/rot;
	if(dt == 0){
		dt = .01;
	}

	return(dt);
}


//Xbee function
void SendVals(float x,float y,float theta,float sonar1,float sonar2)
{
	//------------setup NXTbee
  nxtEnableHSPort();
  nxtHS_Mode = hsRawMode;
  nxtSetHSBaudRate(9600);
	//------------end setup

	//------------define variables
  int offset = 0;
  string packet1="";
  string packet2="";
  string packet3="";
  string packet4="";
  string packet5="";
  string str="";
  ubyte us [90];
  char temp;
	//------------end define variables

	//------------start data organization
	//str 'packet' holds data to be sent to NXTbee

	long x1 = (long)(x*100);	//round to nearest 2 decimal
	strcat(packet1,"$");		//start character
  str = (long) x1;
  strcat(packet1,str);
  strcat(packet1,",");

  long y1 = (long)(y*100);
  str = (long) y1;
  strcat(packet2,str);
  strcat(packet2,",");

  long theta1 = (long)(theta*100);
  str = (long) theta1;
  strcat(packet3,str);
  strcat(packet3,",");

  long xsonar1 = (long)(sonar1*100);
  str = (long) xsonar1;
  strcat(packet4,str);
  strcat(packet4,",");

    long xsonar2 = (long)(sonar2*100);
  str = (long) xsonar2;
  strcat(packet5,str);


  strcat(packet5,"\r\n");
	//--------------end data organization

	//--------------start SEND sequence

	  for (int i = 0 ; i< strlen(packet1);i++)
	{
		temp= stringGetChar(packet1,i);
		us[i]=(ubyte)temp;
	}

	offset = strlen(packet1);

		for (int j = 0 ; j < strlen(packet2);j++)
	{
		temp= stringGetChar(packet2,j);
		us[j + offset]=(ubyte)temp;

	}

	offset = offset + strlen(packet2);

		for (int k = 0 ; k < strlen(packet3);k++)
	{
		temp= stringGetChar(packet3,k);
		us[k + offset]=(ubyte)temp;
	}

	offset = offset + strlen(packet3);

		for (int l = 0 ; l < strlen(packet4);l++)
	{
		temp= stringGetChar(packet4,l);
		us[l + offset]=(ubyte)temp;
	}

	offset = offset + strlen(packet4);

		for (int m = 0 ; m < strlen(packet5);m++)
	{
		temp= stringGetChar(packet5,m);
		us[m + offset]=(ubyte)temp;
	}

	int packetSize = strlen(packet1) + strlen(packet2) + strlen(packet3) + strlen(packet4) + strlen(packet5);
	nxtWriteRawHS(&us[0], packetSize);        //send ubyte array

	//--------------end SEND sequence

}


/************************************************************************************************/
//Tasks

//Jacobian Task
task Jacobian(){
	//Define the update interval in seconds
	float dt = 0.01;

	//Clear motor encoders
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;

	while(true){	//Loop forever
		//Set the angle
		float theta = pos[2];

		//Get the starting encoder values
		float eL0 = nMotorEncoder[motorL];
		float eR0 = nMotorEncoder[motorR];

		//wait a bit for the encoders to move
		wait1Msec(dt*1000);

		//Calculate the change in encoder values
		float deL = nMotorEncoder[motorL] - eL0;
		float deR = nMotorEncoder[motorR] - eR0;

		//Calculate the angular velocities
			//Note the conversion from degrees to radians
		float phiL = deL/dt * PI/180;
		float phiR = deR/dt * PI/180;

		//Calculate the velocities in the inertial frame
		float xDot = 0.5*(rl*cos(theta)*phiL + rr*cos(theta)*phiR);
		float yDot = 0.5*(rl*sin(theta)*phiL + rr*sin(theta)*phiR);
		float thetaDot = 0.5/a*(-rl*phiL+rr*phiR);

		//Calculate the change in position in the inertial frame
		float dx = xDot*dt;
		float dy = yDot*dt;
		float dtheta = thetaDot*dt;

		//Prevent other tasks from altering variables
		hogCPU();

		//Calculate new position
		pos[0] = pos[0] + dx;
		pos[1] = pos[1] + dy;
		pos[2] = pos[2] + dtheta;

		//Allow other tasks to alter variables
		releaseCPU();
	}
}


//Sonar Task
task Sonar(){
	float dt = 0.01; //sample time in seconds

	while(true){
		//Prevent other tasks from altering variables
		hogCPU();

		//Read the sensors
		distL = SensorValue[sonarL]/2.54;
		distR = SensorValue[sonarR]/2.54;

		//Allow other tasks to alter variables
		releaseCPU();

		wait1Msec(dt*1000);
	}
}

//Xbee Task
task Xbee(){
	float dt = 0.1; //Sample time in seconds

	while(true){
		//Prevent other tasks from altering variables
		hogCPU();

		//Store variables to intermediates
			//This is unnecessary if the SendVals function is fast
			//Hogging the CPU would also be unnecessary as a result
		float x = pos[0];
		float y = pos[1];
		float t = pos[2];
		float d1 = distL;
		float d2 = distR;

		//Allow other tasks to alter variables
		releaseCPU();

		//Send the intermediate variables
		SendVals(x,y,t,d1,d2);

		//Wait to take next sample
		wait1Msec(dt*1000);
	}
}

/************************************************************************************************/
task main(){

	//Start the Jacobian task
	startTask(Jacobian);

	//Start the Sonar task
	startTask(Sonar);

	//Start the Xbee task
	startTask(Xbee);

		//Read in the Waypoints
	const int numWaypoints = 18;
	float waypoints[numWaypoints][3] = {
		{0,0,0},
		{14,0,0},
		{14,0,PI/2},
		{14,10,PI/2},
		{14,20,PI/2},
		{14,30,PI/2},
		{14,40,PI/2},
		{14,50,PI/2},
		{14,58,PI/2},
		{14,58,PI},
		{7,58,PI},
		{-2,58,PI},
		{-2,58,PI/2},
		{-2,70,PI/2},
		{-2,80,PI/2},
		{-2,80,0},
		{10,80,0},
		{19,80,0}
		};

	//Loop through each waypoint
	for(int n = 0; n < numWaypoints; n++){

		//DIVE!!! if it's the last point

		//read current position
		hogCPU();
		float x = pos[0];
		float y = pos[1];
		float theta = pos[2];
		releaseCPU();

		//Calculate the change in position
		float dx = waypoints[n][0]-x;
		float dy = waypoints[n][1]-y;
		float dtheta = waypoints[n][2]-theta;

		//Calculate the change in time
		float dt = DeltaT(dx, dy, dtheta);

		//Calculate the differential motion
		float xDot = dx/dt;
		float yDot = dy/dt;
		float thetaDot = dtheta/dt;

		//Calculate the required angular velocities
			//Inverse Jacobian
		float phiL = (cos(theta)*xDot + sin(theta)*yDot - a*thetaDot)/rl;
		float phiR = (cos(theta)*xDot + sin(theta)*yDot + a*thetaDot)/rr;

		//Convert angular velocity to motor power
			//Use the slope from motor models
		float powerL = slopeL*phiL;
		float powerR = slopeR*phiR;

		//Start motors
		motor[motorL] = powerL;
		motor[motorR] = powerR;

		wait1Msec(dt*1000);
	}

	//stop the motors
	motor[motorL] = 0;
	motor[motorR] = 0;

	//DIVE!!!
	//motor[motorL] = 100;
	//motor[motorR] = 100;
	//wait1Msec(250);
	//motor[motorL] = 0;
	//motor[motorR] = 0;

	//Wait for Eight. Then Kill!!!
	
		SendVals(-255,-255,-255,-255,-255);
	wait1Msec(1000);
			SendVals(-255,-255,-255,-255,-255);
			wait1Msec(1000);
					SendVals(-255,-255,-255,-255,-255);
					wait10Msec(1000);
	stopAllTasks();


}
